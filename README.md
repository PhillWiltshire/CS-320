# CS-320
My final project in CS 320 creating and testing using JUnit tests

Below you will find my reflection to questions about this project and coding in general:

How can I ensure that my code, program, or software is functional and secure?
I can ensure my code is functional by using unit tests to verify that individual methods behave correctly. I also manually test the entire program to make sure everything works together. To make my software secure, I validate inputs to avoid bad data entering the system, I handle exceptions properly to prevent crashes, and I keep sensitive operations protected from unauthorized changes. I also avoid hard-coding important values and make sure that error messages don't reveal too much information about the system. Reviewing the code and looking for weak points helps make the program more reliable and safer.

How do I interpret user needs and incorporate them into a program?
I interpret user needs by carefully reading the requirements and understanding what the user expects the program to do. When the requirements aren’t totally clear, I break them down into specific actions or features the user would want. If I still don't understand all the requirements, then I follow up with the parties involved to see I they can clarify. I always think about the user's perspective — asking questions like "What would be easiest for them?" and "What would make sense when they use this?" I always think of the ease at which I can order from Amazon. I think you should remove as many barriers between the paying customer and the service that you provide. I incorporate those needs into the program by designing clear methods that solve user problems directly, avoiding unnecessary complexity, and providing useful feedback if something goes wrong.

How do I approach designing software?
I approach designing software by starting with a plan. I outline the key features needed based on the user requirements, and then break them down into smaller pieces like classes, methods, and data structures. I prioritize simplicity, modularity, and scalability, so the code is easier to test, maintain, and expand later if needed. I also think about possible errors or edge cases upfront, so I can build better error handling from the beginning. Throughout the design, I stay flexible — if I find a better solution while coding, I adjust the design to keep improving it. Good design means planning ahead but also being ready to adapt.
